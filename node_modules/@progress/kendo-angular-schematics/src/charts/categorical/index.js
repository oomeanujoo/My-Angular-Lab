/**-----------------------------------------------------------------------------------------
* Copyright Â© 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chart = void 0;
const core_1 = require("@angular-devkit/core");
const strings_1 = require("@angular-devkit/core/src/utils/strings");
const schematics_1 = require("@angular-devkit/schematics");
const path_1 = require("path");
const utils_1 = require("../../utils");
const schema_1 = require("./schema");
const data_1 = require("./files/data");
const classify = core_1.strings.classify;
const arrayify = (args) => args.map(s => `'${s}'`).join(", ");
function chart(_options) {
    return (_tree, _context) => {
        _options.name = (0, path_1.basename)(_options.name);
        const defaults = {
            style: "css"
        };
        let path = (0, path_1.normalize)('/' + (0, path_1.dirname)((_options.path + '/' + _options.name)));
        if (process.platform == "win32") {
            path = path.replace(/\\/g, '/');
        }
        const parsedComplexOptions = (0, utils_1.parseComplexOptions)(['series', 'categoryAxis', 'valueAxis'], _options);
        // Autofill properties... These will require a lot of "if"-s in the templates otherwise.
        if (parsedComplexOptions?.series?.length > 0 && parsedComplexOptions?.categoryAxis?.length > 0) {
            const defaultCategoryField = parsedComplexOptions?.categoryAxis?.[0]?.name ?? "category";
            console.log("Has series and categories. Default category field: " + defaultCategoryField);
            for (const s of parsedComplexOptions.series ?? []) {
                console.log("Series " + JSON.stringify(s) + " categoryField: " + s.categoryField);
                if (!s.categoryField) {
                    console.log("Category field using default: " + defaultCategoryField);
                    s.categoryField = defaultCategoryField;
                }
            }
        }
        const overrides = {};
        if (_options.dataSource == schema_1.DataSource.Example) {
            overrides.series = [
                { field: "lemons", categoryField: "season", name: "Lemons", type: schema_1.SeriesType.line },
                { field: "apples", categoryField: "season", name: "Apples", type: schema_1.SeriesType.line },
                { field: "mangos", categoryField: "season", name: "Mangos", type: schema_1.SeriesType.line }
            ];
            overrides.categoryAxis = [
                { type: schema_1.CategoryAxisType.category, name: "season", title: "Season" }
            ];
            overrides.valueAxis = [
                { type: schema_1.ValueAxisType.numeric, name: "Quantity", title: "Quantity" }
            ];
        }
        const templateOptions = {
            ...defaults,
            ..._options,
            ...parsedComplexOptions,
            ...overrides,
            classify,
            dasherize: strings_1.dasherize,
            arrayify
        };
        const templateSource = (0, schematics_1.apply)((0, schematics_1.url)(_options.inlineTemplate ? './files/inline' : './files/html'), [
            (0, schematics_1.template)(templateOptions),
            (0, schematics_1.move)(_options.path),
        ]);
        const angularComponentOptions = {
            path: _options.path,
            name: _options.name,
            inlineTemplate: _options.inlineTemplate,
            inlineStyle: _options.inlineStyle,
            skipTests: _options.skipTests,
            style: templateOptions.style
        };
        if (_options.dataSource == schema_1.DataSource.Example) {
            // Import the example datasource
            _tree.create(`${_options.path}/${(0, strings_1.dasherize)(_options.name)}/data.ts`, data_1.seriesSourceCode);
        }
        else if (_options.dataSource == schema_1.DataSource['Mock Data']) {
            let seriesSourceCode = `export const seriesData = [{`;
            const series = templateOptions.series ?? [];
            const categoryAxis = templateOptions.categoryAxis ?? [];
            const valueAxis = templateOptions.valueAxis ?? [];
            const primaryAxisType = categoryAxis[0]?.type ?? schema_1.CategoryAxisType.category;
            if (primaryAxisType == schema_1.CategoryAxisType.date) {
                // Generate some fin tech sales data per month.
                const now = new Date();
                const year = now.getUTCFullYear();
                for (let month = 1; month <= 12; month++) {
                    seriesSourceCode += `\n        "${categoryAxis[0].name ?? "date"}": new Date("${year}-${month}"),`;
                    for (const s of series) {
                        seriesSourceCode += `\n        "${s.field}": ${Math.random() * 100},`;
                    }
                    if (month < 12) {
                        seriesSourceCode += `\n    }, {`;
                    }
                }
                // What about a secondary value axis? No idea how these work or map on the same chart.
            }
            else if (primaryAxisType == schema_1.CategoryAxisType.category) {
                // Generate some bar chart worthy categories.
                for (let c = 1; c <= 4; c++) {
                    seriesSourceCode += `\n        "${categoryAxis[0].name ?? "category"}": "${(categoryAxis[0].title ?? categoryAxis[0].name) + " " + c}",`;
                    for (const s of series) {
                        seriesSourceCode += `\n        "${s.field}": ${Math.random() * 100},`;
                    }
                    if (c < 4) {
                        seriesSourceCode += `\n    }, {`;
                    }
                }
                // What about a secondary value axis? No idea how these work or map on the same chart.
            }
            seriesSourceCode += `\n    }];`;
            seriesSourceCode += `\nexport default seriesData;`;
            _tree.create(`${_options.path}/${(0, strings_1.dasherize)(_options.name)}/data.ts`, seriesSourceCode);
        }
        return (0, schematics_1.chain)([
            (0, schematics_1.externalSchematic)('@schematics/angular', 'component', angularComponentOptions),
            (0, schematics_1.mergeWith)(templateSource, schematics_1.MergeStrategy.Overwrite)
        ]);
    };
}
exports.chart = chart;
//# sourceMappingURL=index.js.map